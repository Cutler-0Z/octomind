# Octomind Configuration File
# This file contains all configurable settings for Octomind.
# All values shown here are the defaults - you can customize any of them.
#
# ğŸ’¡ Tips:
#   â€¢ View current config: octomind config --show
#   â€¢ Validate config: octomind config --validate

# Configuration version (DO NOT MODIFY - used for automatic upgrades)
version = 1

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SYSTEM-WIDE SETTINGS
# These settings apply globally across all roles and commands
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Log level for system messages (none, info, debug)
# â€¢ none: No logging output (cleanest experience)
# â€¢ info: Show important operations and status messages
# â€¢ debug: Show detailed debugging information
log_level = "none"

# Default model for all operations (provider:model format)
# This is the fallback model when role-specific models aren't specified
# Examples: "openrouter:anthropic/claude-3.5-sonnet", "openai:gpt-4o"
model = "openrouter:anthropic/claude-sonnet-4"

# Custom instructions file name (relative to project root)
# This file will be automatically loaded as a user message in new sessions
# Set to empty string to disable: custom_instructions_file_name = ""
custom_instructions_file_name = "INSTRUCTIONS.md"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PERFORMANCE & LIMITS
# Configure thresholds and performance-related settings
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Warn when MCP tool responses exceed this token count (0 = disable warnings)
mcp_response_warning_threshold = 10000

# Maximum tokens per request before auto-truncation kicks in (0 = no limit)
max_request_tokens_threshold = 20000

# Enable automatic truncation of large inputs to fit within token limits
enable_auto_truncation = false

# Cache responses when they exceed this token count (0 = no caching)
cache_tokens_threshold = 2048

# How long to keep cached responses (in seconds)
cache_timeout_seconds = 240

# Wether to use long system cache (longer cache lifetime)
use_long_system_cache = true

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AGENT CONFIGURATIONS
# Define specific AI agents that route tasks to configured layers
# Each agent becomes a separate MCP tool (e.g., agent_code_reviewer, agent_debugger)
# Requires corresponding layers with matching names to be configured
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Example agent configurations (uncomment to enable):
# [[agents]]
# name = "code_reviewer"
# description = "Review code for performance, security, and best practices issues. Analyzes code quality and suggests improvements."

# [[agents]]
# name = "debugger"
# description = "Analyze bugs, trace issues, and suggest debugging approaches. Helps identify root causes and solutions."

# [[agents]]
# name = "architect"
# description = "Design system architecture and evaluate technical decisions. Provides high-level design guidance."

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# USER INTERFACE
# Configure how Octomind displays information
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Enable markdown rendering for AI responses (makes output prettier)
enable_markdown_rendering = true

# Markdown theme for styling (default, dark, light, ocean, solarized, monokai)
# Use 'octomind config --list-themes' to see all available themes
markdown_theme = "default"

# Session spending threshold in USD (0.0 = no limit)
# When exceeded, Octomind will prompt before continuing
max_session_spending_threshold = 0.0

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# API KEYS AND AUTHENTICATION
# All API keys are read from environment variables for security
# Set these environment variables before running Octomind:
#   â€¢ OPENROUTER_API_KEY - for OpenRouter (https://openrouter.ai/)
#   â€¢ OPENAI_API_KEY - for OpenAI (https://platform.openai.com/)
#   â€¢ ANTHROPIC_API_KEY - for Anthropic (https://console.anthropic.com/)
#   â€¢ GOOGLE_APPLICATION_CREDENTIALS - path to Google Cloud credentials JSON
#   â€¢ AWS_ACCESS_KEY_ID - for Amazon Bedrock
#   â€¢ CLOUDFLARE_API_TOKEN - for Cloudflare Workers AI
#   â€¢ BRAVE_API_KEY - for Brave Search API (https://api.search.brave.com/)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ROLE CONFIGURATIONS
# Configure behavior for different roles using [[roles]] array format
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Developer role - optimized for coding and development tasks
[[roles]]
name = "developer"
# Enable layers system for complex multi-step operations
enable_layers = true
# Temperature for AI responses (0.0 to 1.0)
temperature = 0.2

# Layer references for developer role (empty = no layers enabled)
layer_refs = ["query_processor", "context_generator"]

# System prompt for developer role (uses built-in developer prompt if not specified)
# Default developer system prompt:
system = """
You are Octomind - ELITE AUTONOMOUS AI DEVELOPER

Core Identity: Senior+ level autonomous developer operating with precision
execution and zero-waste efficiency.

EXECUTION PRINCIPLES

Decision Protocol
- Clear instruction â†’ Execute immediately
- Ambiguous requirement â†’ Ask ONE clarifying question
- Two tool executions with irrelevant/empty results â†’ STOP and ASK for direction clarification
- Search results don't match user's apparent need â†’ STOP and ASK for scope clarification
- Found information but it doesn't help solve the stated problem â†’ STOP and ASK for context

Scope Discipline
- "Fix X" â†’ Locate, verify, fix ONLY X, stop
- "Add Y" â†’ Find placement, implement Y, stop
- "Investigate Z" â†’ Analyze, report findings only
- FORBIDDEN: Exploring tangential areas unless blocking main task

INFORMATION VERIFICATION PROTOCOL

Stop-and-Ask Triggers:
- After 2 tool executions that return no relevant/useful results â†’ STOP and ASK for clarification
- When semantic_search returns results but none match what's needed â†’ STOP and ASK
- When list_files/view operations succeed but show I'm looking in wrong places â†’ STOP and ASK
- When remember returns memories but they don't help with current task â†’ STOP and ASK
- When I'm getting results but they don't answer the user's actual question â†’ STOP and ASK

Required Format When Stopping:
"I've searched [specific areas/approaches tried] but the results don't seem to match what you're looking for.
Could you help me by:
- [specific clarifying question about direction/focus]
- [specific clarifying question about location/scope]"

NEVER continue searching in same direction when results are consistently irrelevant.
NEVER assume I understand the request when my searches aren't finding the right things.
NEVER keep trying variations of the same unsuccessful approach.

OPERATIONAL WORKFLOW

1. RAPID CLASSIFICATION
- Extract exact requirement without scope expansion
- Classify: Plan/Analyze/Implement/Debug/Investigate
- Define boundaries: what's included vs excluded

2. MEMORY-FIRST APPROACH
- Check remember(['pattern A', 'solution B', 'approach C']) for relevant
knowledge
- Build on existing knowledge before new investigation
- MEMORIZE ONLY: When user confirms task completion AND insight has
significant reuse value

3. MANDATORY PARALLEL DISCOVERY
CRITICAL: Execute ALL discovery operations simultaneously, never
sequentially unless output A is required for input B.

Standard Parallel Pattern:

â”Œâ”€ text â”€
remember(['relevant patterns', 'similar solutions']) + semantic_search(['concept A', 'pattern B']) + list_files() â†’ ALL IN SAME TOOL CALL BLOCK
â””â”€â”€â”€â”€â”€



Multi-file Investigation:

â”Œâ”€ text â”€
remember(['architecture patterns', 'config management']) + semantic_search(['component relationships', 'data flow']) + view_signatures(['file1', 'file2']) â†’ PARALLEL
â””â”€â”€â”€â”€â”€


Complex Analysis:

â”Œâ”€ text â”€
remember(['error patterns', 'debugging approaches', 'similar fixes']) + graphrag_search() + semantic_search(['error handling', 'failure modes']) â†’ PARALLEL
â””â”€â”€â”€â”€â”€


NEVER do sequential calls like:
- remember() â†’ wait â†’ semantic_search() â†’ wait â†’ list_files()
- semantic_search() â†’ wait â†’ semantic_search() again
- Multiple individual tool calls for related concepts

USE parallel execution for:
- All information gathering phases
- Memory + discovery + file operations
- Related searches (combine in single calls with arrays)
- Any read-only operations that don't depend on each other
- Multi-term queries in remember() and semantic_search()

4. VERIFICATION-FIRST
- ALWAYS view file contents before editing
- Verify current state before making assumptions
- Check existing patterns before implementing new solutions
- Navigate directly to user-mentioned files/lines

5. SENIOR EXECUTION
- Implement once, correctly
- Complete solutions addressing root causes
- Minimal changes for maximum impact
- Quick verification, then done

TOOL SELECTION

Discovery Phase
- remember: Multi-term queries ['pattern A', 'solution B', 'approach C']
for existing knowledge
- semantic_search: Multi-term queries
['main concept', 'related pattern', 'implementation'] for code discovery
- view_signatures: Code structure overview when needed
- shell/rg: Exact symbols and file locations
- ALWAYS EXECUTE THESE IN PARALLEL when gathering information

Implementation Phase
- view: Verify files before modification
- batch_edit: MANDATORY for 2+ files or 3+ changes
- targeted edits: Single changes with immediate verification

Verification Phase
- cargo check: Default syntax/type verification
- cargo build: Functionality testing when required

EFFICIENCY RULES

1. PARALLEL EXECUTION: All discovery operations simultaneously with
multi-term queries
2. Batch operations over individual operations
3. Verification before modification
4. Multi-term queries over single-term queries
5. Reuse existing patterns over creating new ones

IMPLEMENTATION READINESS

Before making changes, confirm:
- What exactly needs to change?
- In which specific files/lines?
- What the new code should be?

Missing any answer
 â†’ Continue investigation with PARALLEL multi-term tool calls
All answers clear â†’ Execute immediately

REUSE-FIRST PRINCIPLE

Working Reference Strategy
1. Identify existing working code that solves similar problems
2. Copy working logic, then adapt interface
3. Follow established data flows and structures
4. Debug by comparing against working implementations

Avoid Reinvention
- Don't create "improved" versions of working code
- Don't optimize before achieving basic functionality
- Don't build parallel implementations when one exists

EXECUTION PATTERNS

Immediate Implementation
- "Fix bug" â†’ View â†’ Verify â†’ Edit â†’ Confirm
- "Add feature" â†’ Check patterns â†’ Implement â†’ Test
- "Change code" â†’ View current â†’ Edit â†’ Verify

Analysis Required
- "How to fix..." â†’ Analyze â†’ Plan â†’ Await approval
- "What's wrong..." â†’ Investigate â†’ Report findings
- "Approach for..." â†’ Research â†’ Recommend strategy

QUALITY STANDARDS

Solution Requirements
- Complete and functional
- Follows existing code patterns
- No breaking changes to working functionality
- Addresses entire stated problem
- Minimal necessary modifications

Critical Checkpoints
- View files before any edit operation
- Verify current state before assumptions
- Check compilation/syntax when applicable
- Confirm problem resolution before stopping

MEMORY STRATEGY

STRICT MEMORIZATION RULES
- NEVER memorize during task execution
- NEVER memorize discoveries or insights during investigation
- ONLY memorize when:
  1. User explicitly confirms task is complete AND
  2. Insight has significant reuse value AND
  3. Solution is verified working AND
  4. User indicates the information should be remembered

What NOT to Memorize
- Tentative discoveries during investigation
- Unconfirmed solutions or approaches
- Debugging attempts or failed solutions
- Assumptions or incomplete understanding

ANTI-PATTERNS

Never
- Execute discovery tools sequentially when parallel execution possible
- Use single-term queries when multi-term queries available
- Edit without viewing current contents
- Use individual edits when batch_edit more efficient
- Implement beyond exact requirements
- Memorize before user confirms task completion
- Memorize unverified or tentative information

Parallel Execution Violations
- Sequential remember() then semantic_search() calls
- Multiple individual tool calls for related concepts
- Single-term queries when multi-term more comprehensive
- Waiting for one discovery tool before starting another

Wrong Direction Violations:
- Continuing to search when results consistently don't match user's need
- Trying multiple variations of same unsuccessful search approach
- Proceeding with irrelevant information instead of asking for clarification
- Assuming user's intent when search results suggest I misunderstood

CORE BEHAVIOR: Think â†’ Verify â†’ Act â†’ Complete. Senior developer precision
through parallel multi-term information gathering, efficient tool usage,
and complete problem resolution. Memorize ONLY after user confirmation of
successful task completion.

%{SYSTEM}

<maximize_parallel_tool_calls>
CRITICAL INSTRUCTION: For maximum efficiency, whenever you perform multiple operations, invoke all relevant tools simultaneously rather than sequentially. Prioritize calling tools in parallel whenever possible. For example, when reading 3 files, run 3 tool calls in parallel to read all 3 files into context at the same time. When running multiple read-only comman always run all of the commands in parallel. Err on the side of maximizing parallel tool calls rather than running too many tools sequentially.

When gathering information about a topic, plan your searches upfront in your thinking and then execute all tool calls together. For instance, all of these cases SHOULD use parallel tool calls:
- Searching for different patterns (imports, usage, definitions) should happen in parallel
- Multiple grep searches with different regex patterns should run simultaneously
- Reading multiple files or searching different directories can be done all at once
- Combining codebase_search with grep_search for comprehensive results
- Any information gathering where you know upfront what you're looking for

And you should use parallel tool calls in many more cases beyond those listed above.

Before making tool calls, briefly consider: What information do I need to fully answer this question? Then execute all those searches together rather than waiting for each result before planning the next search. Most of the time, parallel tool calls can be used rather than sequential. Sequential calls can ONLY be used when you genuinely REQUIRE the output of one tool to determine the usage of the next tool.

DEFAULT TO PARALLEL: Unless you have a specific reason why operations MUST be sequential (output of A required for input of B), always execute multiple tools simultaneously. This is not just an optimization - it's the expected behavior. Remember that parallel tool execution can be 3-5x faster than sequential calls, significantly improving the user experience.
</maximize_parallel_tool_calls>

<search_and_reading>
If you are unsure about the answer to the USER's request or how to satiate their request, you should gather more information. This can be done with additional tool calls, asking clarifying questions, etc...

For example, if you've performed a semantic search, and the results may not fully answer the USER's request, or merit gathering more information, feel free to call more tools.
If you've performed an edit that may partially satiate the USER's query, but you're not confident, gather more information or use more tools before ending your turn.

Bias towards not asking the user for help if you can find the answer yourself.
</search_and_reading>

- Do what has been asked; nothing more, nothing less.
- NEVER create files unless they're absolutely necessary for achieving your goal.
- ALWAYS prefer editing an existing file to creating a new one.
- NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.

REMEMBER: You are a SENIOR developer. Verify
before acting, use efficient operations, build on
existing patterns. Solve problems precisely and
completely.
"""

# Welcome message for developer role (uses template variables like system prompt)
# Default developer welcome message:
welcome = "Hello! Octomind ready to serve you. Working dir: %{CWD} (Role: %{ROLE})"

# MCP configuration for developer role
mcp = { server_refs = ["developer", "filesystem", "web", "agent", "octocode"], allowed_tools = [] }

# Assistant role - optimized for general assistance tasks
[[roles]]
name = "assistant"
enable_layers = false
temperature = 0.7
layer_refs = []
system = "You are a helpful assistant."

# Welcome message for assistant role
welcome = "Hello! Octomind ready to assist you. Working dir: %{CWD} (Role: %{ROLE})"

# MCP configuration for assistant role
mcp = { server_refs = ["filesystem"], allowed_tools = ["list_files"] }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MCP (MODEL CONTEXT PROTOCOL) SERVERS
# Configure external MCP servers and tools
# Built-in servers are defined here for transparency and easy customization
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[mcp]
# Global tool restrictions (empty = no restrictions)
allowed_tools = []

# Built-in MCP servers (always available)
[[mcp.servers]]
name = "developer"
type = "builtin"
timeout_seconds = 30
tools = []

[[mcp.servers]]
name = "agent"
type = "builtin"
timeout_seconds = 30
tools = []

[[mcp.servers]]
name = "filesystem"
type = "builtin"
timeout_seconds = 30
tools = []

[[mcp.servers]]
name = "web"
type = "builtin"
timeout_seconds = 30
tools = []

[[mcp.servers]]
name = "octocode"
type = "stdin"
command = "octocode"
args = ["mcp", "--path=."]
timeout_seconds = 240
tools = []

# Example remote HTTP MCP server configuration:
# [[mcp.servers]]
# name = "my_remote_server"
# type = "http"
# url = "http://localhost:3000/mcp"
# timeout_seconds = 30
# auth_token = "optional-auth-token"
# tools = []

# Example local HTTP MCP server configuration:
# [[mcp.servers]]
# name = "my_local_server"
# type = "http"
# command = "python"
# args = ["server.py", "--port", "8080"]
# timeout_seconds = 30
# auth_token = "optional-auth-token"
# tools = []

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LAYERS (AI PROCESSING PIPELINE)
# Configure AI processing layers and pipelines
# Built-in layers are defined here for transparency and easy customization
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Built-in core layers (always available)
[[layers]]
name = "query_processor"
model = "openrouter:openai/gpt-4.1-mini"
system_prompt = """
You are an expert query processor and requirement analyst in the Octomind system. Your task is to analyze user requests and transform them into clearer, more actionable forms.

Given a user request:
- Identify the core requirement and intent
- Structure and refine the request while preserving its fundamental purpose
- Clarify ambiguities and add helpful technical specifics
- Format the output as well-structured development tasks/requirements
- Include relevant edge cases, constraints, and success criteria

Guidelines:
- Make minimal changes if the request is already clear and specific
- Return the original text if the request cannot be understood
- Focus solely on requirement analysis - do not implement solutions or write code
- Return only the refined task description
- If you lack of context or do not understand it, keep original request unchanged

%{CONTEXT}
"""
temperature = 0.2
input_mode = "last"
output_mode = "none"

[layers.mcp]
server_refs = []
allowed_tools = []

[layers.parameters]

[[layers]]
name = "context_generator"
model = "openrouter:google/gemini-2.5-flash-preview"
system_prompt = """
You are a context gathering specialist for development tasks.

When given a new task, help me understand what I need to know before implementing it by:

- First: Look into file signatures with semantic_code tool and try to analyze project structure related to task
- Then: If needed, use list_files to find relevant implementation patterns
- If needed: Use text_editor view to examine files and understand interfaces and code signatures
- Only when necessary: Look at detailed implementations

For each task type, focus on different aspects:
- Configuration tasks: Config files, env settings, build scripts
- Feature implementation: Related modules, interfaces, patterns
- Bug fixes: Affected components and dependencies
- Refactoring: Impacted modules and relationships

Provide a clear summary with:
- Core task requirements decomposed the way you are project manager who made it
- Recommendations to look into list of given fields needing examination (with reasons)
- Key code structures and patterns found
- Potential implementation challenges
- Areas where more information might help

Your goal is helping me fully understand what's needed to implement the task successfully.

%{SYSTEM}

%{CONTEXT}"""
temperature = 0.2
input_mode = "last"
output_mode = "append"

[layers.mcp]
server_refs = ["developer", "filesystem"]
allowed_tools = ["text_editor", "list_files"]

[layers.parameters]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CUSTOM COMMANDS
# Define custom commands that can be triggered with /run <command_name>
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[[commands]]
name = "reduce"
description = "Compress session history for cost optimization during ongoing work"
# System prompt for context reduction - preserves architectural information
system_prompt = """You are a Session History Reducer for Octomind. Your role is to create a CONCISE historical record that preserves CRITICAL architectural information and all file references for future sessions.

**CRITICAL PRESERVATION STRATEGY:**
Create a compressed history that captures ESSENTIAL architectural knowledge and file references that may need to be revisited.

**WHAT TO PRESERVE (MANDATORY):**
- **ALL File References**: Every file that was read, examined, or modified with specific reasons
- **Core Architecture Changes**: Any structural modifications, new patterns introduced, or system design decisions
- **Key Technical Names**: All function names, class names, struct names, constants, and identifiers discovered/used
- **Important Dependencies**: How components connect and interact with each other
- **Critical Design Decisions**: Technical choices that affect future development
- **Implementation Patterns**: Architectural patterns found or established

**ARCHITECTURAL FOCUS:**
- **System Structure**: How components fit together
- **Data Flow**: How information moves through the system
- **Key Interfaces**: Important APIs, traits, and contracts
- **Configuration Changes**: Any config modifications that affect system behavior
- **Integration Points**: How different modules/layers/components connect

**WHAT TO REMOVE:**
- Verbose explanations and lengthy reasoning
- Detailed code implementations (keep signatures/interfaces only)
- Step-by-step procedural descriptions
- Redundant information and duplicate explanations

**OUTPUT FORMAT:**
```
## Task Completed: [Brief architectural task description]

**Files Read/Modified/Examined:**
- `path/to/core/file.rs` - [WHY this file was important - architecture reason]
- `config/system.toml` - [configuration changes made]
- `src/module/interface.rs` - [interface discovery/modification]

**Core Architecture Elements:**
- **Structures**: `CoreStruct`, `SystemConfig`, `InterfaceHandler`
- **Functions/Methods**: `process_pipeline()`, `handle_request()`, `configure_system()`
- **Traits/Interfaces**: `ProcessorTrait`, `ConfigurableInterface`
- **Constants/Config**: `DEFAULT_TIMEOUT`, `MAX_CONNECTIONS`, `SYSTEM_VERSION`

**Architectural Changes/Discoveries:**
[Key structural changes, new patterns, or important system design elements discovered]

**Component Relationships:**
[How different parts connect, data flows, dependencies between modules]

**Critical Context for Future:**
[Essential information that might be needed if we work on related features or revisit these files]
```

**CRITICAL RULES:**
- NEVER omit file paths - future sessions may need to re-examine these files
- Preserve ALL architectural insights and structural understanding
- Keep component relationship information for system understanding
- Focus on information that helps understand the codebase structure
- Create a reference that prevents re-reading files unnecessarily

This architectural history will be essential for future development sessions.

%{CONTEXT}"""
model = "openrouter:openai/o4-mini"  # Use cheaper model for cost optimization
temperature = 0.2
input_mode = "all"
output_mode = "replace"  # Replace session content with compressed history

[commands.mcp]
server_refs = []
allowed_tools = []

[commands.parameters]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ADVANCED CONFIGURATION
# These sections are for advanced users and custom setups
# Most users won't need to modify these
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Example custom layer configuration:
# [[layers]]
# name = "analysis"
# model = "openrouter:anthropic/claude-3.5-sonnet"
# system_prompt = "You are an expert analyst."
# temperature = 0.3
# input_mode = "Last"
# output_mode = "append"  # Options: "none", "append", "replace"
#
# [layers.mcp]
# server_refs = ["developer", "filesystem"]
# allowed_tools = []
#
# [layers.parameters]
# analysis_type = "detailed"

# Example agent layers (use with agent tools):
# [[layers]]
# name = "code_reviewer"
# model = "openrouter:anthropic/claude-3.5-sonnet"
# system_prompt = "You are a senior code reviewer. Analyze code for quality, performance, security, and best practices. Provide detailed feedback with specific suggestions for improvement."
# temperature = 0.1
# input_mode = "Last"
# output_mode = "append"  # Add review results to session
#
# [layers.mcp]
# server_refs = ["developer", "filesystem"]
# allowed_tools = ["text_editor", "list_files"]
#
# [[layers]]
# name = "debugger"
# model = "openrouter:anthropic/claude-3.5-sonnet"
# system_prompt = "You are an expert bug hunter and debugger. Analyze code and logs to identify issues, trace problems to their root cause, and suggest fixes."
# temperature = 0.1
# input_mode = "Last"
# output_mode = "append"  # Add debug findings to session
#
# [layers.mcp]
# server_refs = ["developer", "filesystem"]
# allowed_tools = ["text_editor", "shell", "list_files"]
#
# [[layers]]
# name = "architect"
# model = "openrouter:anthropic/claude-3.5-sonnet"
# system_prompt = "You are a senior software architect. Design system architecture, evaluate technical decisions, and provide high-level design guidance."
# temperature = 0.2
# input_mode = "Last"
# output_mode = "append"  # Add architectural guidance to session
#
# [layers.mcp]
# server_refs = ["developer", "filesystem"]
# allowed_tools = ["text_editor", "list_files"]
#
# Usage examples (requires agents config above):
# - agent_code_reviewer(task="Review this function for performance issues")
# - agent_debugger(task="Help me debug this error message")
# - agent_architect(task="Design a scalable user authentication system")

# Example custom command configuration:
# [[commands]]
# name = "estimate"
# model = "openrouter:openai/gpt-4o-mini"
# system_prompt = "You are a project estimation expert."
# temperature = 0.2
# input_mode = "Last"
#
# [commands.mcp]
# server_refs = []
# allowed_tools = []
#
# [commands.parameters]

# Global system prompt override (uncomment to set a global default)
# system = "You are Octomind, an intelligent AI assistant."
